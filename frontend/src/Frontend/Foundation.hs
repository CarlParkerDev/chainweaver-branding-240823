{-# LANGUAGE DataKinds              #-}
{-# LANGUAGE DeriveGeneric          #-}
{-# LANGUAGE ExtendedDefaultRules   #-}
{-# LANGUAGE FlexibleContexts       #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE KindSignatures         #-}
{-# LANGUAGE LambdaCase             #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE OverloadedStrings      #-}
{-# LANGUAGE QuasiQuotes            #-}
{-# LANGUAGE RecursiveDo            #-}
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE StandaloneDeriving     #-}
{-# LANGUAGE TemplateHaskell        #-}
{-# LANGUAGE TypeApplications       #-}
{-# LANGUAGE TypeFamilies           #-}

-- | Definitions common to the whole frontend.
--
--   And commonly used imports.

module Frontend.Foundation
  ( -- * Useful types
    ReflexValue
  , MDynamic
  , LeftmostEv (..)
    -- * Lenses and Prisms
  , makePactLenses
  , makePactPrisms
    -- * Helpers that should really not be here
  , tshow
    -- * Re-exports
  , module Data.Maybe
  , module Reflex.Extended
  , module Reflex.Network.Extended
  , module Data.Semigroup
  , module Data.Foldable
  , module Control.Monad.IO.Class
  , module Language.Javascript.JSaddle
  , module Control.Monad.Fix
  , module GHC.Generics
  ) where

import           Control.Lens
import           Control.Monad.Fix
import           Control.Monad.IO.Class
import           Data.Coerce                 (coerce)
import           Data.Foldable
import           Data.Semigroup
import           Data.Text
import qualified Data.Text                   as T
import           GHC.Generics                (Generic)
import           Language.Haskell.TH         (DecsQ)
import           Language.Haskell.TH.Syntax  (Name)
import           Language.Javascript.JSaddle (MonadJSM (..))
import           Reflex.Extended
import           Reflex.Network.Extended

import           Data.Maybe

-- | Shorthand for Dynamic t (Maybe a).
--
--   Usually used for things that might not be loaded yet.
type MDynamic t a = Dynamic t (Maybe a)

-- | Wrapper around Event with a Monoid instance based on `leftmost`.
newtype LeftmostEv t a = LeftmostEv
  { unLeftmostEv :: Event t a
  }

instance Reflex t => Semigroup (LeftmostEv t a) where
  (LeftmostEv a) <> (LeftmostEv b) = LeftmostEv $ leftmost [a, b]

instance Reflex t => Monoid (LeftmostEv t a) where
  mempty = LeftmostEv never
  mappend = (<>)
  mconcat = LeftmostEv . leftmost . coerce

-- | Lenses in this project should be generated by means of this function.
--
--   We generate lazy classy lenses. Classes make the export lists less tedious
--   and allows for generic code, which will come in handy when the project
--   grows.
--
--   We want lazy lenses so we can uses lenses also in recursive definitions.

makePactLenses :: Name -> DecsQ
makePactLenses =
  makeLensesWith
    ( classyRules         -- So we can use them in recursive definitions:
        & generateLazyPatterns .~ True
        & createClass .~ True
    )

-- | Make Prisms in "pact style".
--
--   Currently this is just standard `makePrisms`
makePactPrisms :: Name -> DecsQ
makePactPrisms = makePrisms

tshow :: Show a => a -> Text
tshow = T.pack . show


-- | Re-use data constructors more flexibly.
type family ReflexValue (f :: * -> *) x where
    ReflexValue (Dynamic t) x = Dynamic t x

    ReflexValue Identity x = x

    ReflexValue (Behavior t) x = Behavior t x

    ReflexValue (Event t) x = Event t x

